'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _utils = require('./utils');

var _SimpleCache = require('./SimpleCache');

var _SimpleCache2 = _interopRequireDefault(_SimpleCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FetchContext = _react2.default.createContext({});

var Fetch = function (_Component) {
  _inherits(Fetch, _Component);

  function Fetch() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Fetch);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Fetch.__proto__ || Object.getPrototypeOf(Fetch)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      request: {
        url: _this.props.url,
        options: _this.props.options
      },
      fetch: _this.fetch.bind(_this),
      clearData: _this.clearData.bind(_this),
      loading: _this.props.manual ? null : true
    }, _this.cache = null, _this.promises = [], _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Fetch, [{
    key: 'getOptions',
    value: function getOptions(options) {
      return (0, _utils.isFunction)(options) ? options() : options;
    }
  }, {
    key: 'setCache',
    value: function setCache(cache) {
      this.cache = this.props.cache === true ? new _SimpleCache2.default() : (0, _utils.isObject)(this.props.cache) ? this.props.cache : null;
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _props = this.props,
          url = _props.url,
          options = _props.options,
          manual = _props.manual,
          onChange = _props.onChange,
          cache = _props.cache;

      this.mounted = true;

      this.setCache(cache);

      if ((0, _utils.isFunction)(onChange)) {
        onChange(this.state);
      }

      if (url && !manual) {
        this.fetch(url, options);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props2 = this.props,
          url = _props2.url,
          options = _props2.options,
          manual = _props2.manual,
          cache = _props2.cache;

      if (url && url !== prevProps.url && !manual) {
        this.fetch(url, options);
      }

      if (cache !== prevProps.cache) {
        this.setCache(cache);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.mounted = false;
    }
  }, {
    key: 'fetch',
    value: function fetch(url, options, updateOptions) {
      var _this2 = this;

      var _props3 = this.props,
          as = _props3.as,
          cache = _props3.cache;


      if (url == null) {
        url = this.props.url;
      }

      options = this.getOptions(options || this.props.options);
      var request = { url: url, options: options };

      if (this.cache && this.cache.get(url)) {
        // Restore cached state
        var promise = this.cache.get(url);
        promise.then(function (cachedState) {
          return _this2.update(cachedState, promise, updateOptions);
        });
        this.promises.push(promise);
      } else {
        this.update({ request: request, loading: true }, null, updateOptions);

        var _promise = this.props.fetchFunction(url, options).then(function (response) {
          var dataPromise = (0, _utils.isFunction)(as) ? as(response) : (0, _utils.isObject)(as) ? (0, _utils.parseBody)(response, as) : as === 'auto' ? (0, _utils.parseBody)(response) : response[as]();

          return dataPromise.then(function (data) {
            return { response: response, data: data };
          }).catch(function (error) {
            return { response: response, data: error };
          });
        }).then(function (_ref2) {
          var _newState;

          var response = _ref2.response,
              data = _ref2.data;

          var newState = (_newState = {
            request: request,
            loading: false
          }, _defineProperty(_newState, response.ok ? 'error' : 'data', undefined), _defineProperty(_newState, response.ok ? 'data' : 'error', data), _defineProperty(_newState, 'response', response), _newState);

          _this2.update(newState, _promise, updateOptions);

          return newState;
        }).catch(function (error) {
          // Catch request errors with no response (CORS issues, etc)
          var newState = {
            request: request,
            data: undefined,
            error: error,
            loading: false
          };

          _this2.update(newState, _promise, updateOptions);

          // Rethrow so not to swallow errors, especially from errors within handlers (children func / onChange)
          throw error;

          return newState;
        });

        this.promises.push(_promise);

        if (this.cache) {
          this.cache.set(url, _promise);
        }

        return _promise;
      }
    }
  }, {
    key: 'clearData',
    value: function clearData() {
      this.setState({ data: undefined });
    }
  }, {
    key: 'update',
    value: function update(nextState, currentPromise) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (currentPromise) {
        // Handle (i.e. ignore) promises resolved out of order from requests
        var index = this.promises.indexOf(currentPromise);
        if (index === -1) {
          // Ignore update as a later request/promise has already been processed
          return;
        }

        // Remove currently resolved promise and any outstanding promises
        // (which will cause them to be ignored when they do resolve/reject)
        this.promises.splice(0, index + 1);
      }

      var _props4 = this.props,
          onChange = _props4.onChange,
          onDataChange = _props4.onDataChange;


      var data = undefined;
      if (nextState.data && nextState.data !== this.state.data && (0, _utils.isFunction)(onDataChange)) {
        data = onDataChange(nextState.data, options.ignorePreviousData ? undefined : this.state.data);
      }

      if ((0, _utils.isFunction)(onChange)) {
        // Always call onChange even if unmounted.  Useful for `POST` requests with a redirect
        onChange(_extends({}, this.state, nextState, data !== undefined && { data: data }));
      }

      // Ignore passing state down if no longer mounted
      if (this.mounted) {
        // If `onDataChange` prop returned a value, we use it for data passed down to the children function
        this.setState(_extends({}, nextState, data !== undefined && { data: data }));
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;


      return _react2.default.createElement(
        FetchContext.Provider,
        { value: this.state },
        (0, _utils.isFunction)(children) ? _react2.default.createElement(
          FetchContext.Consumer,
          null,
          children
        ) : children
      );
    }
  }]);

  return Fetch;
}(_react.Component);

Fetch.defaultProps = {
  as: 'auto',
  fetchFunction: function fetchFunction(url, options) {
    return fetch(url, options);
  }
};
Fetch.Consumer = FetchContext.Consumer;
exports.default = Fetch;